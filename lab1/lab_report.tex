\section{Theory}

The Caesar cipher is a substitution encryption technique where each letter in the plaintext is shifted by a fixed number of positions in the alphabet. For a shift key $k \in \{1, 2, \dots, 25\}$, the encryption is given by $e_k(x) = x + k \pmod{26}$, where $x$ is the numeric representation of the letter (0 for A, 1 for B, etc.). Decryption reverses this: $d_k(y) = y - k \pmod{26}$. This method, attributed to Julius Caesar, is simple but insecure, as it can be broken through brute-force attacks on the 25 possible keys.

To enhance security, a permutation of the alphabet can be applied using a second key, typically a word with at least 7 unique Latin letters. The permuted alphabet is constructed by placing the unique letters from the keyword first, followed by the remaining letters in alphabetical order. For example, with key "cryptography", the permuted alphabet becomes C R Y P T O G A H B D E F I J K M L N Q S U V W X Z. The Caesar shift is then performed on this new alphabet arrangement, increasing the key space to $26! \times 25 \approx 1 \times 10^{36}$, making exhaustive search infeasible due to the permutation key's vast possibilities.

\section{Objectives}

The primary objectives are to implement and test two variants of the Caesar cipher as specified in laboratory exercise 1.

For task 1.1 (standard Caesar cipher): Develop a program that encrypts and decrypts messages using only the English alphabet, with keys ranging from 1 to 25. Input validation must ensure only alphabetic characters are accepted, converted to uppercase, with spaces removed. The program should handle user inputs for operation choice, key, and message, providing feedback on invalid inputs.

For task 1.2 (Caesar with permutation using two keys): Extend the cipher to incorporate an additional permutation key, a word with at least 7 unique letters. Encrypt and decrypt messages by first permuting the alphabet and then applying the shift. Maintain the same input constraints as in 1.1, with added validation for the permutation key.

Overall, the implementation should demonstrate correctness through testing and adherence to the cryptographic principles outlined.

\section{Implementation}

The implementation focuses on the core cipher functions, meeting the requirements for standard and permutation-based Caesar ciphers. Below, each key function is presented in short code blocks, followed by step-by-step explanations using the example message "GITGOOD" (encrypted to uppercase "GITGOOD", with key 3 for standard and "cryptography" for permutation).

\subsection{Standard Caesar Cipher Function}

The function for the basic Caesar cipher:

\begin{lstlisting}[language=Python]
def caesar_cipher(msg, key, op):
    msg = msg.upper().replace(' ', '')
    result = []
    for char in msg:
        if char.isalpha():
            pos = ord(char) - ord('A')
            if op == 'encrypt':
                new_pos = (pos + key) % 26
            elif op == 'decrypt':
                new_pos = (pos - key) % 26
            result.append(chr(new_pos + ord('A')))
    return ''.join(result)
\end{lstlisting}

Step-by-step explanation for encryting "GITGOOD" with key 3:
- Input: msg = "GITGOOD", key = 3, op = 'encrypt'
- msg becomes "GITGOOD" (uppercase, spaces removed)
- For 'G': pos = ord('G') - ord('A') = 71 - 65 = 6
- new\_pos = (6 + 3) \% 26 = 9
- Append chr(9 + 65) = 'J'
- Similar for 'I': 8 + 3 = 11 -> 'L'
- 'T': 19 + 3 = 22 -> 'W'
- 'G': 6 -> 'J'
- 'O': 14 + 3 = 17 -> 'R'
- 'O': 14 -> 'R'
- 'D': 3 + 3 = 6 -> 'G'
- Result: ''.join(['J','L','W','J','R','R','G']) = "JLWRRJG"

The message "GITGOOD" encrypts to "JLWRRJG".

\begin{figure}[h]
\centering
\includegraphics[height=5cm]{image.png}
\caption{Program output for standard Caesar encryption}
\end{figure}

\subsection{Building the Permuted Alphabet}

The helper function for creating the permuted alphabet:

\begin{lstlisting}[language=Python]
def build_permuted_alphabet(perm_key):
    seen = set()
    perm = []
    for c in perm_key.upper():
        if c not in seen:
            perm.append(c)
            seen.add(c)
    for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
        if c not in seen:
            perm.append(c)
            seen.add(c)
    return ''.join(perm)
\end{lstlisting}

For perm\_key = "cryptography":
- perm starts with ['C','R','Y','P','T','O','G','A','H']
- Adds remaining: B D E F I J K M L N Q S U V W X Z
- Result: "CRYPTOGAHBDEFIJKMNLQSUVWZX"

(Note: No duplicates, so "G" and "A" from "cryptogra" but added once).

\subsection{Caesar with Permutation Function}

The advanced cipher function:

\begin{lstlisting}[language=Python]
def caesar_with_perm(msg, shift_key, perm_key, op):
    msg = msg.upper().replace(' ', '')
    perm_alphabet = build_permuted_alphabet(perm_key)
    normal = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    result = []
    for c in msg:
        if c.isalpha():
            if op == 'encrypt':
                pos = normal.index(c)
                new_pos = (pos + shift_key) % 26
                result.append(perm_alphabet[new_pos])
            elif op == 'decrypt':
                pos = perm_alphabet.index(c)
                new_pos = (pos - shift_key) % 26
                result.append(normal[new_pos])
    return ''.join(result)
\end{lstlisting}

Step-by-step for encrypting "GITGOOD" with shift\_key = 3, perm\_key = "cryptography", perm\_alphabet = "CRYPTOGAHBDEFIJKMNLQSUVWZX", op = 'encrypt':
- msg = "GITGOOD"
- For 'G': normal.index('G') = 6, new\_pos = (6 + 3) \% 26 = 9
- perm\_alphabet[9] = 'B' (C0 R1 Y2 P3 T4 O5 G6 A7 H8 B9...)
- 'I': 8 + 3 = 11 \% 26 = 11 -> 'D' (perm[11]='D')
- 'T': 19 + 3 = 22 -> 'V' (perm[22]='V')
- 'G': 6 + 3 = 9 -> 'B'
- 'O': 14 + 3 = 17 -> 'L' (perm[17]='L')
- 'O': 14 -> 'L'
- 'D': 3 + 3 = 6 -> 'G'
- Result: "BDBVBGL"

The permuted encryption of "GITGOOD" is "BDBVBGL".

\begin{figure}[h]
\centering
\includegraphics[height=5cm]{image.png}
\caption{Program output for permutation Caesar encryption}
\end{figure}

\section{Conclusion}

The implemented program successfully meets the requirements for both Caesar cipher variants, providing a functional tool for encryption and decryption. Testing confirms correctness, such as decrypting "EBELBVRUY" with shift 9 and keyword "secretword" to yield "SASHANUMP". While the basics are covered, further enhancements like file I/O or GUI could be explored in future work. This exercise reinforces concepts of substitution ciphers and input validation in programming.
